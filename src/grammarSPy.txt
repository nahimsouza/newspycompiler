
# comment

stmt: simple_stmt | compound_stmt
simple_stmt: small_stmt (';' small_stmt)* NEWLINE
small_stmt: (expr_stmt | print_stmt  | flow_stmt)

expr_stmt: targetlist augassign listmaker
augassign: ('=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=')
targetlist = target ("," target)* 
target = NAME

# For normal assignments, additional restrictions enforced by the interpreter
print_stmt: 'print' ( test (',' test)* )
flow_stmt: break_stmt | continue_stmt | return_stmt 
break_stmt: 'break'
continue_stmt: 'continue'
return_stmt: 'return' test

compound_stmt: if_stmt | while_stmt | for_stmt | funcdef | classdef
if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
while_stmt: 'while' test ':' suite ['else' ':' suite]
for_stmt: 'for' exprlist 'in' atom ':' suite ['else' ':' suite] |
	  'for' exprlist 'in' 'range' '(' NUMBER ',' NUMBER ')' ':' suite ['else' ':' suite] 
suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT

funcdef: 'def' NAME parameters ':' suite
parameters: '(' [varargslist] ')'
varargslist: ([fpdef ['=' test] (',' fpdef ['=' test])* ] )
fpdef: NAME | '(' fplist ')'
fplist: fpdef (',' fpdef)* 

classdef: 'class' NAME ['(' [atom [',' atom]* ] ')'] ':' suite

test: or_test ['if' or_test 'else' test]
or_test: and_test ('or' and_test)*
and_test: not_test ('and' not_test)*
not_test: 'not' not_test | comparison
comparison: expr (comp_op expr)*
comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
expr: xor_expr ('|' xor_expr)*
xor_expr: and_expr ('^' and_expr)*
and_expr: arith_expr ('&' arith_expr)*
arith_expr: term (('+'|'-') term)*
term: factor (('*'|'/'|'%'|'//') factor)*
factor: ('+'|'-'|'~') factor | atom
atom: '[' [listmaker] ']' | NAME | NUMBER | STRING+

listmaker: test (',' test)* 




# o primeiro uso de uma variável deve definir o seu tipo (sem tipagem dinâmica)
# STRING:  ''' (?)* ''' >> STRING eh qualquer caractere entre aspas ("") ou aspas simples('')
# NUMBER: int ou float
# self é uma palavra-chave e deve ser tratado
# não é necessário implementar property
# não vamos trabalhar com herança

====================================================

$ quando tiver NEWLINE na gramática, talvez seja melhor considerar NEWLINE+ 
para nao ter problema com INDENT/DEDENT OU tratar no Lexer(??)

$ importante: estamos considerando apenas '\t' como indentacao

$ Por que tinha mudado isso?? >> term: factor (('*'|'/'|'%'|'//') (('int'|'float') '(' arith_expr ')' | factor))*


=====================================================

Análise Semântica:
    1. Verificar se nome é uma palavra chave.
        1.1 - funcao
        1.2 - variavel
        1.3 - classe
    2. Primeiro uso da variavel define seu tipo.
        2.1 - precisa ver se uma variavel ja foi declarada
        2.2 - se a variavel ja foi declarada, nao pode associar com outro tipo
        2.3 - se a variavel nao havia sido declarada, associar com o tipo
    3. ver escopo dos nomes
        3.1 - nao pode repetir nomes de variaveis dentro da mesma classe (local)
        3.2 - nao pode repetir nomes de variaveis dentro da mesma funcao (local)
        3.3 - nao pode repetir nomes de variaveis globais 
        3.4 - nao pode repetir nome da classe
    4. verificar tipos das variaveis nas operacoes
        4.1 - nao pode somar/subtrair/mult/div/etc... um inteiro com uma string
        4.2 - comparacoes só podem ser feitas com tipos iguais (algumas só com inteiros: >=, <=, etc)
    5. verificar nomes invalidos de variaveis (por ex, comecando com numero: 3var = 2)



*** precisa ver nos testes depois, se falta alguma analise semantica.
        
        
